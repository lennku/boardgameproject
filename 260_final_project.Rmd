---
title: "Board Game Project Final Report"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "What Makes a Board Game Good?"
author: "Shimin Bi, Shi Chen, Yanying Qiu, Melissa Zhao"
date: "Dec 6, 2017"
output:
  html_document:
    toc: true
    toc_depth: 2
    df_print: paged
    number_sections: true
geometry: margin=1in
fontsize: 12pt
---
\newcommand{\noin}{\noindent}    
\newcommand{\Var}{\text{Var}}    
\newcommand{\Cov}{\text{Cov}}    
\newcommand{\bs}{\boldsymbol}
\newcommand{\mb}{\mathbf}

\allowdisplaybreaks

\definecolor{myblue}{RGB}{0,128,255}
\newenvironment{answer}{\par\color{myblue}}{\par}

# Section 1. Overview and Motivation
## 1.1 Background
We all love Settlers of Catan, but what is it about Catan that makes it so addictive? There are many different components of a board game that give it a lot of variations. Different board games can have various maximum or minimum number of players, varying length of play time, different themes, mechanisms, designers or even different difficulty! We are curious to find out which of these attributes actually make a board game a good one, measured by player ratings. With data collected from boardgamegeek.com, we have player ratings on thousands of board games and their features. We are interested to do some exploratory analysis on the features and potentially build models to predict which board games are more likely to be loved by players.

## 1.2 Objectives
We identified the following objectives for our project:  
1. Investigate the possible traits of high-rating board games using ggplot2 package in R.  
2. Build models to predict the success of a new board game and find important features of the successful games (defined by high average player rating).  
3. Recommend board games to players based on certain specified criteria or other games that they love.

***



# Section 2. Initial Questions
## 2.1 Initial Questions
The first question we asked was:  
__What are the strongest predictors of a board game's success (in terms of average player rating)?__

We began to find in our EDA that some general variables, such as rank or number of votes, although very predictive of rating, are not useful since they are not features of board games that board game manufacturers or players can control. 

## 2.2 New Questions 
Due to the above mentioned problem, our question then evolved to "**what are some useful predictors of a board game's success (in terms of rating)**?" We found that there were several categories in game **categories** and game **mechanics** that were predictive of rating, and zoned in our models to develop a predictive model based on these categorical variables and some general variables, such as weight (game complexity) and year.

Other questions curious about include:  
1. different stratifications in our dataset, such as games by age groups and single/multiplayer involvement.  
2. How game preferences and characteristics changed over time (board game evolution).
3. Whether different machine learning methods would help us predict ratings better, and compared their RMSEs. 
4. If we could use the variables we've gathered in our dataset to build a good board game recommender using Euclidean distances between board game features. 

***



```{r, include=FALSE}
library(ggplot2)
library(dslabs)
library(tidyverse)
library(dplyr)
library(readr)
library(tidyr)
library(caret)
library(lazyeval)
library(randomForest)
library(proxy)
library(knitr)
library(RColorBrewer)
library(purrr)
library(stringr)
library(grid)
```

# Section 3. Data
## 3.1 Data Source
Our board game data comes from a data set on Kaggle.com. The link to the data set is:  
[link] (https://www.kaggle.com/mrpantherson/board-game-data/data)

## 3.2 Data Cleaning & Processing
Our data cleaning work involves 3 parts:  
1. Replace Wrong Values  
2. Recode Numerical Values to Categorical Values  
3. Hot-code Mechanics and Category Columns  

### 3.2.1 Replacing Wrong Values
We found several variables that need to be checked and replaced with appropriate values, including
* min_players
* max_players
* weight
* avg_time
* min_time
* max_time
* year  

Find all cells with value = 0 and cells with values not making sense. Search the original website to find information and overwrite them. Also recoding some continuos variables to categorical.
```{r}
game <- read.csv("bgg_data.csv")

### Overwriting non-sense cells
# min_players
game$min_players[1616] <- 1; game$min_players[1962] <- 1; game$min_players[2273] <- 1 
game$min_players[2408] <- 1; game$min_players[2693] <- 1; game$min_players[3332] <- 1 
game$min_players[3850] <- 1; game$min_players[3902] <- 1; game$min_players[4145] <- 1 
game$min_players[4247] <- 1; game$min_players[4311] <- 1; game$min_players[4442] <- 1 
game$min_players[4480] <- 1; game$min_players[4815] <- 1 

# max_players
game$max_players[1616] <- NA; game$max_players[1962] <- NA; game$max_players[2273] <- NA
game$max_players[2408] <- NA; game$max_players[2687] <- 2; game$max_players[2739] <- 4
game$max_players[2818] <- 2; game$max_players[3332] <- 1; game$max_players[3356] <- 4
game$max_players[3570] <- 2; game$max_players[3724] <- 2; game$max_players[3875] <- 2
game$max_players[3902] <- NA; game$max_players[4016] <- 2; game$max_players[4145] <- NA
game$max_players[4241] <- 2; game$max_players[4354] <- 2; game$max_players[4437] <- 2
game$max_players[4442] <- NA; game$max_players[4480] <- NA; game$max_players[4504] <- 2
game$max_players[4528] <- 2; game$max_players[4540] <- 2; game$max_players[4795] <- 2
game$max_players[4815] <- NA; game$max_players[4988] <- 2

# weight
game$weight[1477] <- NA; game$weight[4381] <- NA; game$weight[4521] <- NA

# min_time, avg_time and max_time are cleaned in excel and re-imported back
game <- read.csv("bgg_clean_dat.csv", sep = " ", header = T)
```

### 3.2.2 Recoding
We tried to recode the following 
* min_players - to categories single player, multi-player or party game
* max_players - to categories single player, multi-player or party game
* min_time - to categories 0 (short), 1(medium), 2(long)
* avg_time - to categories 0 (short), 1(medium), 2(long)
* weight - to categories 0(easy), 1(medium), 2(hard)  

```{r}
# recode players
game$single_player = 0
game$single_player[game$min_players == 1] = 1
game$multi_player = 0
game$multi_player[game$min_players > 1 & game$max_players <= 4] = 1
game$party_player = 0
game$party_player[game$max_players > 4] = 1
# recode min_time
# 0 = short,  1 = medium, 2 = long
quantile(game$min_time, na.rm = T) 
game$cate_mintime = 0
game$cate_mintime[game$min_time >= 30 & game$min_time <= 90] = 1
game$cate_mintime[game$min_time > 90] = 2
# recode avg_time
# 0 = short,  1 = medium, 2 = long
quantile(game$avg_time, na.rm = T)
game$cate_avgtime = 0
game$cate_avgtime[game$avg_time >= 30 & game$avg_time <= 120] = 1
game$cate_avgtime[game$avg_time > 120] = 2
# recode weight
# 0 = easy, 1 = medium, 2 = hard
quantile(game$weight, na.rm = T)
game$cate_weight = 0
game$cate_weight[game$weight >= 1.73885 & game$weight <= 2.8889] = 1
game$cate_weight[game$weight > 2.8889] = 2

# write final cleaned csv and import csv
write.table(game, "bgg_final_clean_dat.csv", sep = "|")
game <- read.csv("bgg_final_clean_dat.csv", sep = "|", header = T)
```

### 3.2.3 Hot-Coding
For each board game, it can have multiple mechanics or categories. We split the mechanics and categories into separate columns with each boradgame having 0 or 1 for each of the mechanic and category.
```{r}
# recode mechanic
# find unique mechanics
mech_str <- paste(as.character(game$mechanic), collapse = ", ")
mech_unique <- unique(strsplit(mech_str, ", ")[[1]])
mech_unique_lower <- unlist(lapply(mech_unique, function(x) {paste(strsplit(tolower(x), " ")[[1]], collapse = "_")}))

# create one empty column for each unique mechanic
mechanic_col <- data.frame(matrix(0, ncol = length(mech_unique_lower), nrow = dim(game)[1]))
colnames(mechanic_col) <- mech_unique_lower

# fill in the values of the mechanic columns
fill_mech_col <- function(df, mechanic_col) {
  for (i in 1:dim(df)[1]) {
    mech_col_num <- which(mech_unique %in% c(strsplit(as.character(df$mechanic[i]), ", ")[[1]]))
    for (j in mech_col_num) {
      mechanic_col[i, j] <- 1
    }
  }
  return(mechanic_col)
}
mechanic_col <- fill_mech_col(game, mechanic_col)

# recode categories
# find unique categories
cat_str <- paste(as.character(game$category), collapse = ", ")
cat_unique <- unique(strsplit(cat_str, ", ")[[1]])
cat_unique_lower <- unlist(lapply(cat_unique, function(x) {paste(strsplit(tolower(x), " ")[[1]], collapse = "_")}))

# create one empty column for each unique category
cat_col <- data.frame(matrix(0, ncol = length(cat_unique_lower), nrow = dim(game)[1]))
colnames(cat_col) <- cat_unique_lower

# fill in the values of the category columns
fill_cat_col <- function(df, cat_col) {
  for (i in 1:dim(df)[1]) {
    cat_col_num <- which(cat_unique %in% c(strsplit(as.character(df$category[i]), ", ")[[1]]))
    for (j in cat_col_num) {
      cat_col[i, j] <- 1
    }
  }
  return(cat_col)
}

cat_col <- fill_cat_col(game, cat_col)

df_new <- cbind(game, mechanic_col)
write.table(df_new, 'df_w_mechanic', sep = "|")
df_new2 <- cbind(game, cat_col)
write.table(df_new2, 'df_w_cat', sep = "|")

df_w_mechanic <- read.csv('df_w_mechanic', sep = "|")
df_w_cat <- read.csv('df_w_cat', sep = "|")
drops <- c('none')
df_mech_new <- df_w_mechanic[ , !(names(df_w_mechanic) %in% drops)]
df_mech_new$memory_mechanic <- df_mech_new$memory
df_mech_final <- df_mech_new[ , !(names(df_mech_new) %in% 'memory')]
df_cat_new <- df_w_cat[ , !(names(df_w_cat) %in% drops)]
df_cat_final <- df_cat_new[, 27:109]
df_recode_final <- cbind(df_mech_final, df_cat_final)
write.table(df_recode_final, 'df_recode_final_1127', sep = "|")
```

***

# Section 4. Exploratory Data Analysis
```{r}
game <- read.csv("df_recode_final_1127", sep = "|")
```

## 4.1 Summary Plots
### 4.1.1 Mean Geek Rating and Mean Average Rating by Category/Theme of Games

__Figure 1.1: Avg rating vs geek rating across game ranks by categories__
```{r}
#loading game without separation of mech and cate into indicator variables 
game1 <- read.csv("bgg_final_clean_dat.csv", sep = "|", header = T)

# Functions
split_into_multiple <- function(column, pattern = ", ", into_prefix){
  cols <- str_split_fixed(column, pattern, n = Inf)
  cols[which(cols == "")] <- NA
  cols <- as_tibble(cols)
  m <- dim(cols)[2]
  names(cols) <- paste(into_prefix, 1:m, sep = "_")
  return(cols)
}

#Splitting 
game1 <- game1 %>% bind_cols(split_into_multiple(game1$category,',','category')) %>%
  bind_cols(split_into_multiple(game1$mechanic,',','mechanic'))

#Cleaning
game1 <- game1 %>% select(-category, -mechanic, -designer, -image_url)

#Tidying
tidygame <- game1 %>% gather(key, categories, category_1:category_11, na.rm = TRUE) %>% select(-key) %>%
  gather(key, mechanics, mechanic_1:mechanic_18, na.rm = TRUE) %>% select(-key)

tidygame$mechanics <- trimws(tidygame$mechanics)
tidygame$categories <- trimws(tidygame$categories)

#Categories vs ratings
tidygame %>% 
 group_by(categories) %>% summarize(avgrating = mean(avg_rating), avggeek = mean(geek_rating), avgrank = mean(rank)) %>%  
  ggplot() +
  geom_point(aes(reorder(categories, avgrank), avggeek, color = 'avg_geek'), size = 0.5) +
  geom_point(aes(categories, avgrating, color = 'avg_rating'), size = 0.5) + 
  scale_colour_manual(name="Rating", values=c(avg_geek="red", avg_rating="blue")) +
  theme(axis.text=element_text(size=8, angle = 60, hjust =1)) +
  ylab("Rating") +
  xlab("Rank") +
  ggtitle("Ratings by Categories") 
```



__Figure 1.2: Avg rating vs geek rating across game ranks by mechanics__
```{r}
#Mechanics vs ratings
tidygame %>% group_by(mechanics) %>% summarize(avgrating = mean(avg_rating), avggeek = mean(geek_rating), avgrank = mean(rank)) %>%
  ggplot() +
  geom_point(aes(reorder(mechanics, avgrank), avggeek, color = 'avg_geek'), size = 0.5) +
  geom_point(aes(mechanics, avgrating, color = 'avg_rating'), size = 0.5) +
  scale_colour_manual(name="Rating", values=c(avg_geek="red", avg_rating="blue")) + #adds legend
  theme(axis.text=element_text(size=9, angle = 60, hjust = 1)) +
  ylab("Rating") +
  xlab("Rank") +
  ggtitle("Ratings by Mechanics") 
```

The plots above show that the geek ratings are lower than average ratings across all categories or mechanics in general.  

### 4.1.2 Trends and Ranking across Age Groups
__Figure 2: Average Rating vs. Age__

```{r}
df_recode_final <- read.csv('df_recode_final_1127', sep = "|")
df_age <- df_recode_final %>% 
  filter(age <= 21 & age > 0)
df_age$age <- as.factor(df_age$age)
df_age %>%
  ggplot() +
  geom_boxplot(aes(x = age, y = avg_rating, col = age)) +
  theme(legend.position="none") +
  ggtitle("Game Rating by Age") +
  ylab("Average Rating") +
  xlab("Age")
```

We looked at average ratings across different minimum age groups. We found that board games tend to be rated lower for those catering to younger kids, and games with minimum recommended ages of 16-17 are the highest rated. This is probably because boardgamegeek.com users are generally at least teenagers so they prefer more challenging games appropriate to their age.  

### 4.1.3 Plots and ranking among 3 Age Groups
__Generate agecat according to IQR__  

Then, we reported the top 10 ranked games for each age group and listed out their average ratings and geek ratings. The age groups were divided by interquartile ranges of 0-8, 9-12, and 13-21. We can clearly see that board games favored by each age group are different, and that games favored by average population and geeks are different in all 3 age groups.

```{r}
Q1 <- quantile(game$age, 0.25) 
Q3 <- quantile(game$age, 0.75) 
game <- game %>% mutate(agecat = ifelse (age %in% range(0,Q1), 1, ifelse(age %in% range(Q1, Q3), 2, 3)))
```

Get the top 10 rated (based on avg_rating) for each age group, game_id
```{r}
# agecat == 1 when age %in% range(0,Q1)
game %>% 
  select(avg_rating, geek_rating, rank, age, agecat, game_id, names) %>%
  filter(agecat == 1) %>% 
  arrange(desc(avg_rating)) %>% 
  head(10) %>% kable
# agecat == 2 when age %in% range(Q1,Q3)
game %>% 
  select(avg_rating, geek_rating, rank, age, agecat, game_id, names) %>%
  filter(agecat == 2) %>% 
  arrange(desc(avg_rating)) %>% 
  head(10) %>% kable
# agecat == 3 when age %in% range(Q3,)
game %>% 
  select(avg_rating, geek_rating, rank, age, agecat, game_id, names) %>%
  filter(agecat == 3) %>% 
  arrange(desc(avg_rating)) %>% 
  head(10) %>% kable
```

Get the top 10 rated (based on avg_geek rating) for each age group, game_id.
```{r}
# agecat == 1 when age %in% range(0,Q1)
game %>% 
  select(avg_rating, geek_rating, rank, age, agecat, game_id, names) %>%
  filter(agecat == 1) %>% 
  arrange(desc(geek_rating)) %>% 
  head(10) %>% kable
# agecat == 2 when age %in% range(Q1,Q3)
game %>% 
  select(avg_rating, geek_rating, rank, age, agecat, game_id, names) %>%
  filter(agecat == 2) %>% 
  arrange(desc(geek_rating)) %>% 
  head(10) %>% kable
# agecat == 3 when age %in% range(Q3,)
game %>% 
  select(avg_rating, geek_rating, rank, age, agecat, game_id, names) %>%
  filter(agecat == 3) %>% 
  arrange(desc(geek_rating)) %>% 
  head(10) %>% kable
```

For each age group, get top 100 ranked games, and then find the top 10 rated (by freq) mechanics for each age group.
```{r}
# agecat == 1 when age %in% range(0,Q1)
top100_1 <- game %>% 
  filter(agecat == 1) %>% 
  arrange(rank) %>%
  mutate(new_rank = 1:n()) %>%
  filter(new_rank <= 100) 
mechanic <- top100_1[,27:76]
m1 <- mechanic %>% colSums() %>% sort(decreasing = T) %>% head(10)  
# agecat == 2 when age %in% range(Q1,Q3)
top100_2 <- game %>% 
  filter(agecat == 2) %>% 
  arrange(rank) %>%
  mutate(new_rank = 1:n()) %>%
  filter(new_rank <= 100) 
mechanic <- top100_2[,27:76]
m2 <- mechanic %>% colSums() %>% sort(decreasing = T) %>% head(10)  
# agecat == 3 when age %in% range(Q3,)
top100_3 <- game %>% 
  filter(agecat == 3) %>% 
  arrange(rank) %>%
  mutate(new_rank = 1:n()) %>%
  filter(new_rank <= 100) 
mechanic <- top100_3[,27:76]
m3 <- mechanic %>% colSums() %>% sort(decreasing = T) %>% head(10)  
```

We plotted the top 10 ranked game mechanics for each age group. We realized that the three age groups have similar sets of preferred board game categories, as well as mechanics.  

__Figure 3.1: Top 10 Ranked Game Mechanics for each Age Group__
```{r}
m11 <- data.frame(names=names(m1), m1)
m22 <- data.frame(names=names(m2), m2)
m33 <- data.frame(names=names(m3), m3)
p1 <- m11 %>% mutate(freq = m1) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ffcccc") +
  theme_light() +
  theme(axis.text=element_text(size=8)) +
  xlab('Age 0-8') +
  ylab('Frequency') +
  ylim(0,50)+
  coord_flip() 
p2 <- m22 %>% mutate(freq = m2) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ff9999") +
  theme_light() +
  theme(axis.text=element_text(size=8)) +
  xlab('Age 9-12') +
  ylab('Frequency') +
  ylim(0,50)+
  coord_flip()
p3 <-  m33 %>% mutate(freq = m3) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ff4d4d") +
  theme_light() +
  theme(axis.text=element_text(size=8)) +
  xlab('Age 13-21') +
  ylab('Frequency') +
  ylim(0,50)+
  coord_flip()
grid.newpage()
grid.draw(rbind(ggplotGrob(p1), ggplotGrob(p2),  ggplotGrob(p3),size = "last"))
```

__Figure 3.2: Top 10 Ranked Game Categories for each Age Group__

```{r}

c1 <- top100_1[,78:160] %>% colSums() %>% sort(decreasing = T) %>% head(10)  
c2 <- top100_2[,78:160] %>% colSums() %>% sort(decreasing = T) %>% head(10)  
c3 <- top100_3[,78:160] %>% colSums() %>% sort(decreasing = T) %>% head(10)  

c11 <- data.frame(names=names(c1), c1)
c22 <- data.frame(names=c(names(c2)[1:7], 'manufacturing', names(c2)[9:10]), c2)
c33 <- data.frame(names=names(c3), c3)


pc1 <- c11 %>% mutate(freq = c1) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ffcccc") +
  theme(axis.text=element_text(size=8)) +
  xlab('Age 0-8') +
  ylab('Frequency') +
  ylim(0,40)+
  coord_flip() 
 

pc2 <- c22 %>% mutate(freq = c2) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ff9999") +
  theme(axis.text=element_text(size=8)) +
  xlab('Age 9-12') +
  ylab('Frequency') +
  ylim(0,40)+
  coord_flip()

pc3 <-  c33 %>% mutate(freq = c3) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ff4d4d") +
  theme(axis.text=element_text(size=8)) +
  xlab('Age 13-21') +
  ylab('Frequency') +
  ylim(0,40)+
  coord_flip()

grid.newpage()
grid.draw(rbind(ggplotGrob(pc1), ggplotGrob(pc2),  ggplotGrob(pc3),size = "last"))
```

### 4.1.4 Trends and Ranking across Player Groups
Firstly, we reported the top 10 ranked games for each player group a nd listed out their average ratings and geek ratings. Single-player, multiplayer, and party games are defined as those with 1 player, 2-4 players, and 4+ players respectively. We found that a large difference exist between the top-ranked games based on geek ratings or average ratings.  

__Top 10 rated (based on avg_rating), game_id__

```{r}
#single_player
game %>% 
  select(avg_rating, geek_rating, rank, single_player, game_id, names) %>%
  filter(single_player == 1) %>% 
  arrange(desc(avg_rating)) %>% 
  head(10) %>% kable

#multi_player
game %>% 
  select(avg_rating, geek_rating, rank, multi_player, game_id, names) %>%
  filter(multi_player == 1) %>% 
  arrange(desc(avg_rating)) %>% 
  head(10) %>% kable

#party_player
game %>% 
  select(avg_rating, geek_rating, rank, party_player, game_id, names) %>%
  filter(party_player == 1) %>% 
  arrange(desc(avg_rating)) %>% 
  head(10) %>% kable
```

__Top 10 rated (based on avg_geek rating) for each player group, game_id__

```{r}
#single_player
game %>% 
  select(avg_rating, geek_rating, rank, single_player, game_id, names) %>%
  filter(single_player == 1) %>% 
  arrange(desc(geek_rating)) %>% 
  head(10) %>% kable

#multi_player
game %>% 
  select(avg_rating, geek_rating, rank, multi_player, game_id, names) %>%
  filter(multi_player == 1) %>% 
  arrange(desc(geek_rating)) %>% 
  head(10) %>% kable

#party_player
game %>% 
  select(avg_rating, geek_rating, rank, party_player, game_id, names) %>%
  filter(party_player == 1) %>% 
  arrange(desc(geek_rating)) %>% 
  head(10) %>% kable
```

Then we plotted the top 10 ranked game mechanics for each player group. We realized that the three age groups have similar sets of preferred board game categories, as well as mechanics.  

__Figure 4.1: Plot the top 10 rated (avg_geek) for each player group, mechanic__

```{r}
#single-player 
top100_1 <- game %>% 
   filter(single_player == 1) %>% 
  arrange(rank) %>%
  mutate(new_rank = 1:n()) %>%
  filter(new_rank <= 100) 
mechanic <- top100_1[,27:76]
m1 <- mechanic %>% colSums() %>% sort(decreasing = T) %>% head(10)  
  
# multi-player 
top100_2 <- game %>% 
  filter(multi_player == 1) %>% 
  arrange(rank) %>%
  mutate(new_rank = 1:n()) %>%
  filter(new_rank <= 100) 
mechanic <- top100_2[,27:76]
m2 <- mechanic %>% colSums() %>% sort(decreasing = T) %>% head(10)  

# party-player
top100_3 <- game %>% 
  filter(party_player == 1) %>% 
  arrange(rank) %>%
  mutate(new_rank = 1:n()) %>%
  filter(new_rank <= 100) 
mechanic <- top100_3[,27:76]
m3 <- mechanic %>% colSums() %>% sort(decreasing = T) %>% head(10)  

# plot
m11 <- data.frame(names=names(m1), m1)
m22 <- data.frame(names=names(m2), m2)
m33 <- data.frame(names=names(m3), m3)


p1 <- m11 %>% mutate(freq = m1) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ffcccc") +
  theme(axis.text=element_text(size=8)) +
  xlab('single_player') +
  ylab('Frequency') +
  ylim(0,50)+
  coord_flip() 
 

p2 <- m22 %>% mutate(freq = m2) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ff9999") +
  theme(axis.text=element_text(size=8)) +
  xlab('multi_player') +
  ylab('Frequency') +
  ylim(0,50)+
  coord_flip()

p3 <-  m33 %>% mutate(freq = m3) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ff4d4d") +
  theme(axis.text=element_text(size=8)) +
  xlab('party_player') +
  ylab('Frequency') +
  ylim(0,50)+
  coord_flip()

grid.newpage()
grid.draw(rbind(ggplotGrob(p1), ggplotGrob(p2),  ggplotGrob(p3),size = "last"))
```

__Figure 4.2: Plot the top 10 rated (avg_geek) for each player group, categories__

```{r}
c1 <- top100_1[,78:160] %>% colSums() %>% sort(decreasing = T) %>% head(10)  
c2 <- top100_2[,78:160] %>% colSums() %>% sort(decreasing = T) %>% head(10)  
c3 <- top100_3[,78:160] %>% colSums() %>% sort(decreasing = T) %>% head(10)  

c11 <- data.frame(names=names(c1), c1)
c22 <- data.frame(names=names(c2), c2)
c33 <- data.frame(names=names(c3), c3)


pc1 <- c11 %>% mutate(freq = c1) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ffcccc") +
  theme(axis.text=element_text(size=8)) +
  xlab('single_player') +
  ylab('Frequency') +
  ylim(0,40) +
  coord_flip() 
 

pc2 <- c22 %>% mutate(freq = c2) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ff9999") +
  theme(axis.text=element_text(size=8)) +
  xlab('multi_player') +
  ylab('Frequency') +
  ylim(0,40) +
  coord_flip()

pc3 <-  c33 %>% mutate(freq = c3) %>%
  ggplot () +
  geom_bar(aes(x = reorder(names, freq), y= freq), stat = "identity", fill= "#ff4d4d") +
  theme(axis.text=element_text(size=8)) +
  xlab('party_player') +
  ylab('Frequency') +
  ylim(0,40) +
  coord_flip()

grid.newpage()
grid.draw(rbind(ggplotGrob(pc1), ggplotGrob(pc2),  ggplotGrob(pc3),size = "last"))
```

### 4.1.5 Explore the Optimal Game Difficulty
__Figure 5: Game Difficulty and Rating__

```{r}
# average rating and difficulty
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2")
df_recode_diff <- df_recode_final
df_recode_diff$min_time_category <- df_recode_final$cate_mintime
df_recode_diff %>%
  ggplot() +
  geom_point(aes(x = weight, y = avg_rating, col = factor(min_time_category))) +
  xlab("Game Difficulty Level") +
  ylab("Average Rating") +
  ggtitle("Relationship of Game Difficulty and Rating") +
  scale_colour_manual("", 
                      breaks = c("card_game", "wargame", "fantasy", "economic", "fighting", "science_fiction"),
                      values = cbPalette[1:6])
```
We noticed that game rating increases as the difficulty level goes up, and that more difficult games need more time to play as expected.  

### 4.1.6 Explore Beta Coefficients from Linear Regression Model
Firstly, we calculated the beta Coefficients of Game Categories (linear model with categories variable only) and visualized them. From preliminary univariate linear regression of categories on average rating, error bars represent the 95% confidence interval of each coefficient estimate. We found that several game categories, such as Environmental, Medical, Farming, Civilization, are positively associated with average rating.  

Secondly, we calculated the beta Coefficients of Game Mechanics (linear model with mechanics variable only) and visualized them. From a similar univariate linear regression of mechanics on average rating, such as Worker Placement, Grid Movement, Variable Phase Order, Role Playing, we see that several types of mechanics are positively associated with average rating.

__Figure 6.1: Beta Coefficients of Game Categories  (linear model with categories variable only)__
```{r}

model1 <- lm(geek_rating ~ categories,data = tidygame)
coeff <- as.data.frame(model1$coefficients)
coeff$category <- as.factor(rownames(coeff))
colnames(coeff) <- c("coef","covariates")
confint_cat <- as.data.frame(confint(model1)) 

coeff_cat <- coeff[,]
coeff_cat$covariates <- gsub("categories", "", coeff_cat$covariates)
head(coeff_cat)

coeff_cat_error <- bind_cols(coeff_cat, confint_cat) 
colnames(coeff_cat_error) <- c("coef", "covariates", "lower", "upper")

ggplot(coeff_cat_error[-1,], aes( x=reorder(covariates, coef)))+
  geom_errorbar(aes(x =reorder(covariates, coef), ymin = lower, ymax = upper), color = "grey70") +
  geom_point(aes(y = coef), col = "#C1275C") +
  coord_flip() +
  labs(title = "Linear Model Coefficients for Category",y="Coefficients",x="Category")+
  scale_fill_gradient2(low = "light grey", mid = "grey70",
  high = "#C1275C", midpoint = 0.25) +
  theme_light() +
  guides(fill=guide_legend(title="Coefficient values")) +
  theme(axis.text=element_text(size=6))

```

** Figure 6.2: Beta Coefficients of Game Mechanics (linear model with mechanics variable only) **
```{r}
model2 <- lm(geek_rating ~ mechanics, data = tidygame)
coeff <- as.data.frame(model2$coefficients)
coeff$category <- as.factor(rownames(coeff))
colnames(coeff) <- c("coef","covariates")
confint_mech <- as.data.frame(confint(model2)) 

coeff_mech <- coeff[,]
coeff_mech$covariates <- gsub("mechanics", "", coeff_mech$covariates)
coeff_mech_error <- bind_cols(coeff_mech, confint_mech) 
colnames(coeff_mech_error) <- c("coef", "covariates", "lower", "upper")

ggplot(coeff_mech_error[-1,], aes( x=reorder(covariates, coef)))+
  geom_errorbar(aes(x =reorder(covariates, coef), ymin = lower, ymax = upper), color = "grey70") +
  geom_point(aes(y = coef), col = "#C1275C") +
  coord_flip() +
  labs(title = "Linear Model Coefficients for Mechanics",y="Coefficients",x="Mechanics")+
  scale_fill_gradient2(low = "light grey", mid = "grey70",
  high = "#C1275C", midpoint = 0.25) +
  theme_light() +
  guides(fill=guide_legend(title="Coefficient values")) +
  theme(axis.text=element_text(size=8))
```

## 4.2 Board Game Evolution  
### 4.2.1 General Trends
Firstly, we plotted the distribution of average rating and geek rating across years, we found that the average geek rating is always lower than the average rating, and that the two average ratings did not change much before 2015, but diverged after 2015, and that diverge may be due to low number of players in most recent board games.  

Secondly, we plotted the distribution of game difficulty over the years. We noticed that the trend of difficulty in board games decreased from 1980 to 2017, and that the level of difficulty fluctuates across years, and that the most difficult board game in year 2018 is likely to be an outlier.  

Then, we visualized the change in game popularity over the years and noticed that generally own more board games over the years, however there was a drop after year 2014.

__Figure 1.1: The distribution of average rating and geek rating across years__

```{r}
game %>% group_by(year) %>%
  filter(year > 1980 ) %>%
  summarise(avg_mean = mean(avg_rating), geek_mean = mean(geek_rating)) %>%
  ggplot()+
  geom_point(aes(year, avg_mean, col = 'avg_mean'))+
  geom_line(aes(year, avg_mean, col = 'avg_mean')) +
  geom_point(aes(year,  geek_mean, col = 'geek_mean'))+
  geom_line(aes(year,  geek_mean, col = 'geek_mean')) +
  scale_colour_manual(name="rating", values=c(avg_mean="red",geek_mean ="blue")) +
  ylab("rating") +
  xlab("year") +
  ggtitle('The distribution of average rating and geek rating across years') +
  theme_grey()
```

__Figure 1.2: Changing difficulty of board games across years__

```{r}

game %>% group_by(year) %>%
  filter(year > 1980) %>% 
  summarise(m = mean(weight, na.rm = T)) %>%
  ggplot(aes(year, m))+
  geom_point(color = 'blue')+
  geom_line(color = 'blue') +
  ylab("Difficulty") +
  xlab("year") +
  ggtitle('Changing difficulty of board games across years')+
  theme_grey()
```

__Figure 1.3: The Distribution of Mean Rank of Board Games across Years__

```{r}
game %>% group_by(year) %>%
  filter(year > 1980) %>%
  summarise(m = mean(rank)) %>%
  ggplot(aes(year, m))+
  geom_point(color = 'blue')+
  geom_line(color = 'blue') +
  ylab("Mean Rank") +
  xlab("year") +
  ggtitle('the distribution of mean rank of board games across years')+
  theme_grey()
```

### 4.2.2 Change in Game Mechanics and Themes Over the Years
Finally, we plotted the change in game mechanics and themes over the years 1980-2018.  

For the mechanics, we found that hand management became one of the dominating mechanics in the past few decades, and dice rolling is a long-standing popular mechanic throughout the time. 

For the themes(categories), we noticed that war games were really popular in the 80's, but they became much less popular now; card games gradually gained a lot of popularity; a lot of fantasy games emerged in the last 10 years.

__Figure 2.1: Change in game mechanics__
```{r}
# Change in game mechanics
df_new1 <- game %>% filter(year >= 1980)
df_new1$year_group <- cut(df_new1$year, breaks = c(1980, 1985, 1990, 1995, 2000, 2005, 2010, 2015, 2018), include.lowest = TRUE)
dice_rolling <- df_new1 %>%
    group_by(year_group) %>%
    summarize(percent = sum(dice_rolling, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "dice_rolling")
hand_management <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(hand_management, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "hand_management")
variable_player_powers <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(variable_player_powers, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "variable_player_powers")
set_collection <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(set_collection, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "set_collection")
area_control_._area_influence <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(area_control_._area_influence, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "area_control_._area_influence")
card_drafting <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(card_drafting, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "card_drafting")

cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2")
mechanic_by_year <- as.data.frame(bind_rows(dice_rolling, hand_management, variable_player_powers, set_collection, area_control_._area_influence, card_drafting))
ggplot() + 
  geom_point(aes(x = dice_rolling$year_group, y = dice_rolling$percent, col = 'Dice Rolling')) + 
  geom_line(aes(x = dice_rolling$year_group, y = dice_rolling$percent, group = 1, col = 'Dice Rolling')) +
  geom_point(aes(x = hand_management$year_group, y = hand_management$percent, col = 'Hand Management')) + 
  geom_line(aes(x = hand_management$year_group, y = hand_management$percent, group = 1, col = 'Hand Management')) + 
  geom_point(aes(x = variable_player_powers$year_group, y = variable_player_powers$percent, col = 'Variable Player Powers')) +
  geom_line(aes(x = variable_player_powers$year_group, y = variable_player_powers$percent, group = 1, col = 'Variable Player Powers')) + 
  geom_point(aes(x = set_collection$year_group, y = set_collection$percent, col = 'Set Collection')) + 
  geom_line(aes(x = set_collection$year_group, y = set_collection$percent, group = 1, col = 'Set Collection')) +
  geom_point(aes(x = area_control_._area_influence$year_group, y = area_control_._area_influence$percent, col = 'Area Control/Area Influence')) + 
  geom_line(aes(x = `area_control_._area_influence`$year_group, y = area_control_._area_influence$percent, group = 1, col = 'Area Control/Area Influence')) +
  geom_point(aes(x = card_drafting$year_group, y = card_drafting$percent, col = 'Card Drafting')) + 
  geom_line(aes(x = card_drafting$year_group, y = card_drafting$percent, group = 1, col = 'Card Drafting')) +
  scale_colour_manual("", 
                      breaks = c("Dice Rolling", "Hand Management", "Variable Player Powers", "Set Collection", "Area Control/Area Influence", "Card Drafting"),
                      values = cbPalette[1:6]) +
  scale_x_discrete(breaks = dice_rolling$year_group, 
                   labels = seq(1980, 2015, 5)) +
  xlab("Year") +
  ylab("Percentage of games") +
  ggtitle("Evolution of Game Mechanics 1980 - 2018") +
  theme(legend.position="bottom")
```


__Figure 2.2: Change in Game Categories__
```{r}
# change in game categories
card_game <- df_new1 %>%
    group_by(year_group) %>%
    summarize(percent = sum(card_game, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "card_game")
wargame <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(wargame, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "wargame")
fantasy <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(fantasy, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "fantasy")
economic <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(economic, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "economic")
fighting <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(fighting, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "fighting")
science_fiction <- df_new1 %>%
    group_by(year_group) %>%
    summarise(percent = sum(science_fiction, na.rm = TRUE) / n()) %>%
    mutate(mechanic = "science_fiction")

cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2")
ggplot() + 
  geom_point(aes(x = card_game$year_group, y = card_game$percent, col = 'Card Game')) + 
  geom_line(aes(x = card_game$year_group, y = card_game$percent, group = 1, col = 'Card Game')) +
  geom_point(aes(x = wargame$year_group, y = wargame$percent, col = 'War Game')) + 
  geom_line(aes(x = wargame$year_group, y = wargame$percent, group = 1, col = 'War Game')) + 
  geom_point(aes(x = fantasy$year_group, y = fantasy$percent, col = 'Fantasy')) +
  geom_line(aes(x = fantasy$year_group, y = fantasy$percent, group = 1, col = 'Fantasy')) + 
  geom_point(aes(x = economic$year_group, y = economic$percent, col = 'Economic')) + 
  geom_line(aes(x = economic$year_group, y = economic$percent, group = 1, col = 'Economic')) +
  geom_point(aes(x = fighting$year_group, y = fighting$percent, col = 'Fighting')) + 
  geom_line(aes(x = fighting$year_group, y = fighting$percent, group = 1, col = 'Fighting')) +
  geom_point(aes(x = science_fiction$year_group, y = science_fiction$percent, col = 'Science Fiction')) + 
  geom_line(aes(x = science_fiction$year_group, y = science_fiction$percent, group = 1, col = 'Science Fiction')) +
  scale_colour_manual("", 
                      breaks = c("Card Game", "War Game", "Fantasy", "Economic", "Fighting", "Science Fiction"),
                      values = cbPalette[1:6]) +
  scale_x_discrete(breaks = dice_rolling$year_group, 
                   labels = seq(1980, 2015, 5)) +
  xlab("Year") +
  ylab("Percentage of games") +
  ggtitle("Evolution of Game Categories 1980 - 2018") + 
  theme(legend.position="bottom")
```

***

# Section 5. Predictions with Machine Learning
## 5.1 Objective
We want to predict the success of a board game which is measured by its **average rating** on boardgamegeek.com.

## 5.2 Methods
We tried four different machine learning methods, including linear regression, kth nearest neighbors, random forest, and support vector machine.

__Building train and test set__
```{r}
set.seed(1)
game <- read.csv("df_recode_final_1127",  header =T, sep = "|")

# drop the irrelevant columns like game ID, names, designer
# drop na
g1 <- game[, -c(2:4, 14, 16, 18:19, 77)] #4750  152
g <- drop_na(g1) # 4666  152
#g <- na.omit(g1)
# Spliting data as training and test set. Using createDataPartition() function from caret
inTrain <- createDataPartition(y = g$avg_rating,
                               p=0.8)$Resample
train_set <- slice(g, inTrain)
test_set <- slice(g, -inTrain)

control <- trainControl(method = 'cv', number = 20)
```


### 5.2.1 Linear Regression
```{r}
# Finding the best covariates to test with ML lm method
model <- train(avg_rating ~ .,
             data = train_set,
             method = "lm",
             na.action=na.exclude,
             trControl = control,
             metric = "RMSE")
summary(model)

#Removing NAs
tidygame <- train_set %>% select(avg_rating, year, weight , single_player , multi_player , hand_management , point_to_point_movement , set_collection , variable_player_powers , card_drafting , area_control_._area_influence , campaign_._battle_card_driven , dice_rolling , simultaneous_action_selection , route.network_building , variable_phase_order , grid_movement , storytelling , worker_placement , deck_._pool_building , player_elimination , press_your_luck , hex.and.counter , stock_holding , betting.wagering , line_drawing , rock.paper.scissors , environmental , card_game , economic , wargame , fighting , city_building , farming , murder.mystery) %>% na.omit(.)

#Stepwise selection
lm.null <- lm(avg_rating ~ 1, data = train_set)
lm.full <- lm(avg_rating ~ year + weight + single_player + multi_player + hand_management + point_to_point_movement + set_collection + variable_player_powers + card_drafting + area_control_._area_influence + campaign_._battle_card_driven + dice_rolling + simultaneous_action_selection + route.network_building + variable_phase_order + grid_movement + storytelling + worker_placement + deck_._pool_building + player_elimination + press_your_luck + hex.and.counter + stock_holding + betting.wagering + line_drawing + rock.paper.scissors + environmental + card_game + economic + wargame + fighting + city_building + farming + murder.mystery, data = train_set)
mod1 <- step(lm.null, direction = "both", scope = list(lower = lm.null, upper = lm.full))

#finalized linear model
mod1 <- lm(avg_rating ~ weight + year + wargame + single_player +
    deck_._pool_building + storytelling + grid_movement + hex.and.counter +
    campaign_._battle_card_driven + multi_player + city_building +
    rock.paper.scissors + simultaneous_action_selection + area_control_._area_influence +
    line_drawing + betting.wagering + route.network_building +
    press_your_luck + murder.mystery + fighting + card_drafting +
    stock_holding + variable_player_powers + card_game + point_to_point_movement,
    data = train_set)
summary(mod1)

#predictions vs actual rating
predictions <- predict(mod1, test_set)
cor(predictions, test_set$avg_rating)

#graph of predictions vs actual rating
data.frame(test_set$avg_rating, predictions) %>% ggplot(aes(test_set$avg_rating, predictions)) +
  geom_point(color = "pink") +
  stat_ellipse(color = "pink") +
  xlab("Actual Average Rating") +
  ylab("Predicted Average Rating") +
  ggtitle("Actual vs Predicted Average Rating")

#graph of linear model coefficients by magnitude
mod_coef <- data.frame(mod1$coeff)
mod_coef <- mod_coef %>%
  mutate(variable = rownames(mod_coef))

ggplot(mod_coef[-1,], aes( x=reorder(variable, mod1.coeff), y=mod1.coeff, fill=mod1.coeff))+
  geom_bar(stat="identity") +
  coord_flip() +
  labs(title = "Final Linear Model Coefficients",y="Coefficients",x="Variable")+
  scale_fill_gradient(low="grey50", high="grey50")+
  theme_light() +
  guides(fill=guide_legend(title="Coefficient values"))
```
 
### 5.2.2 K-Nearest Neighbors
```{r}
knnFit <- train(avg_rating ~.,
             data = train_set,
             method = "knn",
             na.action=na.exclude,
             trControl = control,
             preProcess = c("center", "scale"),
             tuneLength = 10)

knnFit

#plot it
knnFit %>% ggplot() +
  geom_point(color='pink') +
  geom_line(color ='pink')

#prediction
knnPredict <- predict(knnFit,newdata = test_set) # 932

#plot actual vs prediction
data <- data.frame(cbind(test_set$avg_rating,knnPredict))
names(data) <- c('avg_rating','knnPredict')

data %>% ggplot(aes(avg_rating, knnPredict)) +
  geom_point(color = 'pink') +
  xlim(c(6,8)) +
  ylim(c(6,8)) +
  ylab('KNN_prediction') +
  xlab('Actual average_rating')
```

### 5.2.3 Random Forest
```{r}
# omit na
#df1_na_omit <- na.omit(game)
# set seed
#set.seed(1)

# create training and testing data
#inTrain <- createDataPartition(y = df1_na_omit$geek_rating,
#                               p=0.8)$Resample
#train_set <- slice(df1_na_omit, inTrain)
#test_set <- slice(df1_na_omit, -inTrain)

# select needed columns
train_set_select <- train_set[, c(2:8, 11, 13:152)]

# run randomForest with all features
#fit <- randomForest(avg_rating ~  .,
#      data = train_set_select,
#      ntree = 500)
fit <- randomForest(avg_rating ~  .,
      data = train_set_select,
      ntree = 500)

# plot feature importance
impt <- as.data.frame(importance(fit))
impt$variable <- names(train_set_select[, -8])
impt <- transform(impt, variable = reorder(variable, IncNodePurity))
impt %>%
  mutate(sort(IncNodePurity, decreasing = TRUE)) %>%
  ggplot() +
  geom_bar(aes(y = IncNodePurity, x = variable), stat = 'identity') +
  coord_flip() +
  ylab("Feature Importance") +
  xlab("Feature") +
  ggtitle("Board Game Features Ranked by Importance")
```

Top 20 Most Important Features
```{r}
# select top 20 most important features
impt_feature <- impt %>%
  mutate(sort(IncNodePurity, decreasing = TRUE)) %>%
  head(20) %>%
  select(variable)
impt_feature <- as.character(as.vector(impt_feature$variable))

impt_feature_df <- impt %>%
  filter(variable %in% impt_feature)
impt_feature_df %>%
  mutate(sort(IncNodePurity, decreasing = TRUE)) %>%
  ggplot() +
  geom_bar(aes(y = IncNodePurity, x = variable), stat = 'identity') +
  coord_flip() +
  ylab("Feature Importance") +
  xlab("Feature") +
  ggtitle("Board Game Features Ranked by Importance")
```

```{r}
# fit the random forest model
# change number of variables randomly sampled as candidates at each split
RMSE_mtry <- c()
for (m in 1:30) {
  fit <- randomForest(avg_rating ~  .,
      data = train_set_select,
      ntree = 100,
      mtry = m)

  # make predictions on test set
  predictions <- predict(fit, test_set)

  # calculate RMSE
  RMSE <- sqrt(sum((predictions - test_set$avg_rating)^2)/length(predictions))
  print(RMSE)
  RMSE_mtry <- c(RMSE_mtry, RMSE)
}

# get minimum RMSE
which.min(RMSE_mtry)

# plot RMSE with mtry
ggplot() +
  geom_line(aes(x = 1:30, y = RMSE_mtry)) +
  geom_point(aes(x = 1:30, y = RMSE_mtry)) +
  ggtitle("Choose the Best Number of Variables to Include at Each Split") +
  xlab("mtry") +
  ylab("RMSE")

# change number of trees to grow
RMSE_ntree <- c()
for (n in 1:10) {
  fit <- randomForest(avg_rating ~  .,
      data = train_set_select,
      ntree = n * 50,
      mtry = which(RMSE_mtry == min(RMSE_mtry)))

  # make predictions on test set
  predictions <- predict(fit, test_set)

  # calculate RMSE
  RMSE <- sqrt(sum((predictions - test_set$avg_rating)^2)/length(predictions))
  print(RMSE)
  RMSE_ntree <- c(RMSE_ntree, RMSE)
}

ggplot() +
  geom_line(aes(x = seq(50, 500, 50), y = RMSE_ntree)) +
  geom_point(aes(x = seq(50, 500, 50), y = RMSE_ntree)) +
  ggtitle("Choose the Best Number of Trees to Grow") +
  xlab("ntree") +
  ylab("RMSE")

which.min(RMSE_ntree)
min(RMSE_ntree)
```

Fit a model using our best mtry and ntree.
```{r}
# best model
fit <- randomForest(avg_rating ~  .,
      data = train_set_select,
      ntree = which.min(RMSE_ntree),
      mtry =  which.min(RMSE_mtry))

# make predictions
predictions <- predict(fit, test_set)

# calculate new RMSE
RMSE <- sqrt(sum((predictions - test_set$avg_rating)^2)/length(predictions))
print(RMSE)

# R^2
R_2 <- 1 - sum((test_set$avg_rating - predictions)^2) / sum((test_set$avg_rating - mean(test_set$avg_rating))^2)
R_2

# plot
ggplot() +
  geom_point(aes(x = test_set$avg_rating, y = predictions), col = "pink") +
  ggtitle("Predictions vs True Average Ratings") +
  xlab("True Average Rating") +
  ylab("Predicted Average Rating")
```

### 5.2.4 Support Vector Machines
```{r}
### support vector machine
#g1 <- game[, -c(2:4, 14, 16, 18:19, 77)] #4750  152
#g <- drop_na(g1) # 4666  152

# Spliting data into training and test set.
#inTrain <- createDataPartition(y = g$avg_rating, p=0.8)$Resample
#train_set <- slice(g1, inTrain)
#test_set <- slice(g, -inTrain)

#control <- trainControl(method = 'cv', number = 20)
svmFit <- train(avg_rating ~.,
             data = train_set,
             method = "svmLinear",
             na.action=na.exclude,
             trControl = control,
             preProcess = c("center", "scale"),
             tuneLength = 10)
svmFit
svmPredict <- predict(svmFit,newdata = test_set)

#plot actual vs prediction
data <- data.frame(cbind(svmPredict, test_set$avg_rating))
names(data) <- c('svmPredict','avg_rating')
data %>% ggplot(aes(avg_rating, svmPredict)) +
  geom_point(color =  'hotpink2') +
  xlim(c(6,8)) +
  ylim(c(6,8)) +
  xlab('Actual average_rating') +
  ylab('SVM_prediction')
```

***

# Section 6. Board Game Recommender
We also built a simple board game recommender where a user can input their favorite board game and we will make recommendations of several board games that we think they might like, based on how similar the games are to their favorite game.
```{r}
# omit na
df1_na_omit <- na.omit(game)

# drop columns not wanted
drops <- c("rank", "bgg_url", "game_id", "image_url", "mechanic", "category", "designer")
df_rec <- df1_na_omit[ , !(names(df1_na_omit) %in% drops)]

# function to get similarity between two boardgames using Euclidean distance
get_most_simi <- function(game_name, df) {
  # get only the mechanics and category columns
  df_new <- df[, c(1, 20:153)]
  
  # create a vector of the features of the user's favorite game
  game_played <- as.numeric(as.vector(df_new[df_new$names == game_name, ]))[-1]
  
  # calculate Euclidean distance between user's favorite game and every other game in our data
  score <- numeric(0)
  for (i in 1:dim(df_new)[1]) {
    score <- c(score, 
               dist(list(game_played, as.numeric(df_new[i, -1])), method = "Euclidean"))
  }
  names(score) <- df_new[, 1]

  games <- names(score)
  score <- as.data.frame(score)
  score$game <- games
  score <- score[order(score$score), ]
  similar_games <- score %>% 
    filter(score < quantile(score, 0.02) & 
           score != 0)
  game_list <- df %>%
    filter(names %in% similar_games$game)
  recommendations <- game_list[order(game_list$geek_rating, decreasing = TRUE), ] %>%
    select(names) %>%
    head(10)
  return(recommendations)
}

# example
# input: Kingdom Builder
get_most_simi("Kingdom Builder", df_rec)
```

***


# Section 7. Final Analysis
The exploratory data analysis and machine learning were used to analyze the board game dataset. From the EDA, we explored the relationships between different characteristics of a board game to the average game rating, and we built models to predict the rating based on possible predictors. Here are some interesting findings. The average rating is different from the geek rating by both categories and mechanics across years. We found more similarity in preferred mechanics than in preferred categories for each age group and each player group. The top rated categories were card game, economics, flighting and fantasy. Card game and fantasy theme were gradually taking over the market, but the war game lost popularity over the years. The top rated mechanics were variable player powers, dice rolling, hand management, and card drafting. Hand management became more popular over the years. Also, the longer the players spent in a game, the more likely they would highly rate this game. 

The four machine learning methods were used to formally assess the association between characteristics of the board games to the average rating. The linear regression based on the stepwise selection by AIC was applied. A final model had 24 significant predictors and RMSE = 0.42. By the regression model, game difficulty most strongly influenced the average rating of a game. Of all significant categories, storytelling was most strongly associated with higher average ratings. Of all significant mechanics, war games were most strongly associated with higher average ratings. Games categorized as rock-paper-scissors games were the most strongly associated with lower average ratings. The kth nearest neighbor using 20 fold cross validation was applied. The optimal k is 23 with RMSE = 0.46. The random forest with ntree = 550 and mtry = 30 was applied to select the top important features. Based on the random forest analysis, game difficulty, year, maximum and minimum time needed to play, age requirement, and player groups were the most important features. The support vector machine using 20 fold cross validation was applied. It resulted the lowest RMSE = 0.35, which means our best model were on average 0.35 points off from the true rating. There were several board game categories and mechanics that tend to do better than others. To maximize the chances of a board game becoming popular, a game designer could attempt making a game in these top categories or using some popular mechanics. 

Based on our prediction, a board game recommender was built. Six relevant board games were recommended for a board game based on Euclidean distance. 
